# Домашнее задание к занятию "`Базы данных, их типы`" - `Фумелли Петр`


Задание 1. СУБД

1.1. Бюджетирование проектов, финансовые отчёты и прогнозирование рисков
Рекомендуемая СУБД: Реляционная (SQL) – PostgreSQL, Oracle, MS SQL Server
Требуется целостность данных и их строгая структура → ACID-транзакции
Финансовые аналитические отчёты требуют мощных SQL-запросов, агрегаций, джойнов
Надёжность и поддержка хранимых процедур для сложных финансовых вычислений

1.1.1 Как ускорить хеширование?

Если хеширование (например, паролей или данных) занимает много времени, можно использовать:
bcrypt, Argon2 – но они медленные
SHA-256, SHA-512 (из библиотеки hashlib) – быстрее, но менее безопасны
Аппаратное ускорение (например, OpenSSL)
Redis для кеширования уже вычисленных хешей

1.2. Лендинги и CRM
Рекомендуемая СУБД:
Для лендингов – NoSQL (MongoDB, Firebase, CouchDB) (гибкость, высокая скорость)
Для CRM – Реляционная (MySQL, PostgreSQL, MS SQL Server) (структурированные данные, связи между лидами, клиентами)
Лендинги часто хранят структурированные + неструктурированные данные (например, JSON)
CRM нуждается в строгих связях между лидами, клиентами, задачами менеджеров

1.2.1 Можно ли всё сделать в одной СУБД?
Да, если выбрать PostgreSQL с поддержкой JSONB. Он позволяет одновременно:
Хранить гибкие данные (лендинги)
Обрабатывать структурированные CRM-данные

1.3. База знаний отдела контроля качества
Рекомендуемая СУБД: Документная NoSQL (MongoDB, ElasticSearch, Firebase)
Хранение корпоративных норм, правил и обучающих материалов (чаще всего в текстовом формате)
Простая структура без сложных реляционных связей
Быстрая полнотекстовая индексация

1.3.1 Можно ли использовать уже существующую СУБД?
Да, если CRM использует PostgreSQL с JSONB – можно в ней же хранить нормативную документацию
Или использовать ElasticSearch (если важен быстрый поиск)

1.4. Логистика (формирование маршрутов, распределение курьеров)
Рекомендуемая СУБД: Графовая (Neo4j, ArangoDB)
Быстрая работа со связями (где какой курьер, какие маршруты, доставки)
Оптимизация маршрутов через графовые алгоритмы (Dijkstra)
Возможность легко масштабироваться

1.4.1. Подключение отдела закупок

Можно использовать одну и ту же СУБД
Логистика + закупки могут быть в Neo4j (если закупки тоже связаны с маршрутами)
Если закупки хранят больше таблиц, то лучше PostgreSQL + связка с Neo4j

1.5. Можно ли решить все задачи одной СУБД?
Да, если выбрать PostgreSQL + расширения для разных типов данных

Единое решение: PostgreSQL
Бюджетирование (финансовые отчёты, аналитика) → Реляционные таблицы, ACID
CRM (лиды, клиенты) → Таблицы + JSONB
Лендинги → JSONB (гибкость, скорость)
База знаний (нормативы, обучение) → Full-text Search + JSONB
Логистика и закупки → PostGIS (геоданные) или связка с Neo4j
Дополнительные технологии для ускорения:
Redis для кеширования
ElasticSearch для быстрого поиска
GraphDB (Neo4j) или PostGIS для логистики
Если нужен более масштабируемый вариант, можно использовать MongoDB для лендингов, PostgreSQL для CRM, Neo4j для логистики.


Задание 2. Транзакции

Пополение баланса

1) Проверка данных пользователя:
   - Проверить номер телефона (правильный формат, существует ли в системе)
   - Проверить баланс пользователя (достаточно ли средств на счёте или карте)

2) Блокировка суммы на счету:
   - Заблокировать нужную сумму на банковском счёте или карте пользователя
   - Гарантия того, что деньги не будут потрачены на другую операцию

3) Создание записи о транзакции:
   - Создать запись в базе данных с указанием:
      Номера телефона
      Суммы пополнения
      Статуса транзакции ("В процессе")
      Времени операции

4) Пополнение баланса телефона:
    - Отправить запрос в платёжную систему оператора мобильной связи
    - Дождаться подтверждения о зачислении средств

5) Обновление статуса транзакции:
    - При успешном пополнении:
        Обновить статус транзакции на "Успешно"
        Разблокировать сумму на банковском счёте и провести списание
    - При неудаче:
        Обновить статус на "Ошибка"
        Разблокировать сумму без списания

6) Уведомление пользователя:
     - Отправить SMS или уведомление о результатах операции:
        Успешное пополнение (с указанием суммы и нового баланса)
        Ошибка пополнения (с указанием причины, если возможно)

Автоплатёж

1) Проверка настроек автоплатежа:
    - Проверить наличие активного автоплатежа (установлен ли лимит, есть ли средства)
    - Проверить условия срабатывания (например, при падении баланса ниже заданного уровня)

2) Инициализация автоплатежа:
    - Система автоматически инициирует пополнение (без участия пользователя)
    - Проверяет баланс на карте или счёте, откуда списываются средства

3) Проверка и блокировка суммы:
    - Аналогично обычной транзакции: проверка и блокировка суммы на карте

4) Пополнение баланса:
    - Отправка запроса в платёжную систему оператора
    - Обновление баланса на стороне оператора

5) Обновление статуса и истории автоплатежа:
    - Обновление статуса транзакции ("Успешно" или "Ошибка")
    - Сохранение информации в истории автоплатежей

6) Уведомление пользователя:

    - Отправка SMS или push-уведомления об автоплатеже
    - Сообщение о результате операции с указанием новой суммы на балансе

Задание 3. SQL vs NoSQL

3.1. В чём основное отличие между SQL и NoSQL?

SQL (Реляционные базы данных):

1) Строгая структура данных: Таблицы с чёткими схемами (столбцы и строки).
2) ACID-транзакции: Атомарность, согласованность, изолированность, долговечность.
3) Язык запросов: Использует SQL (Structured Query Language).
4) Связи между данными: Через JOIN-ы (внешние ключи).
5) Масштабирование: Обычно вертикальное (добавление ресурсов серверу).
Примеры: MySQL, PostgreSQL, Oracle, MS SQL Server.

NoSQL (Нереляционные базы данных):

1) Гибкая структура данных: Нет строгой схемы, данные могут быть разными по структуре.
2) BASE-подход: Гибкость в целостности данных (возможны неустойчивые состояния).

Типы:
Документные (JSON): MongoDB, CouchDB
Ключ-значение: Redis, DynamoDB
Графовые: Neo4j, ArangoDB
Колоночные: Cassandra, HBase
Масштабирование: Горизонтальное (добавление серверов).
Примеры: MongoDB, Redis, Cassandra, Neo4j.

3.2. В каких случаях лучше использовать SQL, а в каких NoSQL?

Когда использовать SQL:

1) Сложные запросы и связи: когда нужно делать много JOIN-ов и сложные аналитические запросы.
2) Чёткая структура данных: когда данные строго типизированы и не меняют свою структуру.
3) Транзакции и целостность данных: когда требуется строгий контроль за целостностью данных (например, банковские операции).
4) Отчётность и аналитика: для создания сложных отчётов с агрегацией данных.
Пример: Финансовые системы, ERP, CRM, учётные системы.

Когда использовать NoSQL:

1) Гибкие данные и изменения схемы: когда структура данных часто меняется (например, динамическое добавление полей).
2) Высокая скорость и производительность: для обработки большого количества запросов с низкой задержкой.
3) Масштабируемость: когда требуется горизонтальное масштабирование (например, социальные сети, игры).
4) Хранение больших объёмов данных: лог-файлы, данные IoT, кэши.
Пример: Социальные сети, каталоги продуктов, чаты, системы рекомендаций.


Задание 4. Кластеры

1) Хранение данных:
HDFS (Hadoop Distributed File System) или Cassandra - надёжное хранение данных и горизонтальное масштабирование

2) Обработка данных:
Apache Spark для вычислений в памяти и параллельной обработки данных - учший выбор для вычислений на 1000 машинах благодаря скорости, масштабируемости и универсальности
MapReduce (в Hadoop) для пакетных вычислений, если скорость не критична

3) СУБД:
Cassandra или HBase для хранения больших объёмов данных
MongoDB для гибких данных (если нужна JSON-структура)
CockroachDB для консистентных ACID-транзакций в распределённой среде
